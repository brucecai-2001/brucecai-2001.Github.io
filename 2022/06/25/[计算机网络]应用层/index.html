<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Xinyu">





<title>计算机网络(2)---应用层 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xinyu&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xinyu&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">计算机网络(2)---应用层</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Xinyu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">June 25, 2022&nbsp;&nbsp;2:05:40</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h1><p>一个HTTP请求报文由请求行（request line）、请求头部（header）空行和请求数据4个部分组成</p>
<p><img src="https://raw.githubusercontent.com/brucecai-2001/Image/master/20220625021021.png"></p>
<h1 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h1><p><img src="https://raw.githubusercontent.com/brucecai-2001/Image/master/20220625021039.png"></p>
<br>
<br>

<h1 id="HTTP-请求行"><a href="#HTTP-请求行" class="headerlink" title="HTTP 请求行"></a>HTTP 请求行</h1><p>在请求行中，URL 就是 <a target="_blank" rel="noopener" href="http://www.163.com/">http://www.163.com</a> ，版本为 HTTP 1.1。这里要说一下的，就是方法。方法有几种类型。对于访问网页来讲，最常用的类型就是 GET。</p>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>顾名思义，GET 就是去服务器获取一些资源。对于访问网页来讲，要获取的资源往往是一个页面。其实也有很多其他的格式，比如说返回一个 JSON 字符串，到底要返回什么，是由服务器端的实现决定的。例如，在云计算中，如果我们的服务器端要提供一个基于 HTTP 协议的 API，获取所有云主机的列表，这就会使用 GET 方法得到，返回的可能是一个 JSON 字符串。字符串里面是一个列表，列表里面是一项的云主机的信息。</p>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>另外一种类型叫做 POST。它需要主动告诉服务端一些信息，而非获取。要告诉服务端什么呢？一般会放在正文里面。正文可以有各种各样的格式。常见的格式也是 JSON。 例如，在云计算里，如果我们的服务器端，要提供一个基于 HTTP 协议的创建云主机的 API，也会用到 POST 方法。这个时候往往需要将“我要创建多大的云主机？多少 CPU 多少内存？多大硬盘？”这些信息放在 JSON 字符串里面，通过 POST 的方法告诉服务器端。</p>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>还有一种类型叫 PUT，就是向指定资源位置上传最新内容。但是，HTTP 的服务器往往是不允许上传文件的，所以 PUT 和 POST 就都变成了要传给服务器东西的方法。在实际使用过程中，这两者还会有稍许的区别。POST 往往是用来创建一个资源的，而 PUT 往往是用来修改一个资源的。 例如，云主机已经创建好了，我想对这个云主机打一个标签，说明这个云主机是生产环境的，另外一个云主机是测试环境的。那怎么修改这个标签呢？往往就是用 PUT 方法。<br><br>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p>
<h3 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h3><p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>再有一种常见的就是 DELETE。这个顾名思义就是用来删除资源的。例如，我们要删除一个云主机，就会调用 DELETE 方法。</p>
<h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>查询指定的 URL 能够支持的方法。会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容</p>
<br>
<br>

<h1 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h1><blockquote>
<p>请求行下面就是我们的首部字段。首部是 key value，通过冒号分隔。这里面，往往保存了一些非常重要的字段。HTTP 头部本质上是一个传递额外重要信息的键值对。主要分为：通用头部，请求头部，响应头部和实体头部。</p>
</blockquote>
<h3 id="R-Accept-Charset"><a href="#R-Accept-Charset" class="headerlink" title="R - Accept-Charset"></a>R - Accept-Charset</h3><p>表示客户端可以接受的字符集。防止传过来的是另外的字符集，从而导致出现乱码。</p>
<h3 id="B-Content-Type"><a href="#B-Content-Type" class="headerlink" title="B - Content-Type"></a>B - Content-Type</h3><p>正文的格式。例如，我们进行 POST 的请求，如果正文是 JSON，那么我们就应该将这个值设置为 JSON。</p>
<h3 id="G-Cache-control"><a href="#G-Cache-control" class="headerlink" title="G - Cache-control"></a>G - Cache-control</h3><p>高并发场景下的系统，在真正的业务逻辑之前，都需要有个接入层，将这些静态资源的请求拦在最外面。<br>当客户端发送的请求中包含 max-age 指令时，如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，那么客户端可以接受缓存的资源；当指定 max-age 值为 0，那么缓存层通常需要将请求转发给应用集群。</p>
<h3 id="R-If-Modified-Since"><a href="#R-If-Modified-Since" class="headerlink" title="R - If-Modified-Since"></a>R - If-Modified-Since</h3><p>也是一个关于缓存的。也就是说，如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最新的资源；如果没有更新，服务端会返回“304 Not Modified”的响应，那客户端就不用下载了，也会节省带宽。</p>
<h3 id="Response-Server"><a href="#Response-Server" class="headerlink" title="Response - Server"></a>Response - Server</h3><p>告知客户端服务器信息</p>
<h3 id="Response-Retry-After"><a href="#Response-Retry-After" class="headerlink" title="Response - Retry-After"></a>Response - Retry-After</h3><p>告知客户端多久后再发送请求</p>
<br>
<br>

<h1 id="HTTP-空行"><a href="#HTTP-空行" class="headerlink" title="HTTP 空行"></a>HTTP 空行</h1><p>最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。</p>
<br>
<br>

<h1 id="HTTP-请求数据"><a href="#HTTP-请求数据" class="headerlink" title="HTTP 请求数据"></a>HTTP 请求数据</h1><p>请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。</p>
<br>
<br>

<h1 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h1><blockquote>
<p>HTTP响应也由三个部分组成，分别是：状态行、消息报头、响应正文。</p>
</blockquote>
<h1 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h1><p>HTTP-Version: 表示服务器HTTP协议的版本<br></p>
<p>Status-Code表示服务器发回的响应状态代码<br></p>
<h1 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h1><p>200 请求成功 <br><br>204 请求成功但无内容返回 <br><br>206 部分请求成功 <br></p>
<p>301 永久移动。请求的资源已被永久地移动到新 URI，返回信息会包含新的 URI，浏览器会自动定向到新 URI <br><br>304 未修改。如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码<br></p>
<p>400 语法错误（前端挨打）<br><br>401 需要认证信息 <br><br>403 拒绝访问  <br><br>404 找不到资源 <br></p>
<p>500 服务器错误（后端挨打）<br><br>501 服务器不支持当前请求所需要的某个功能<br><br>503 由于临时的服务器维护或者过载，服务器当前无法处理请求，一段时间后可能恢复正常（DevOps or IT 挨打）<br></p>
<h1 id="Keep-Alive-和-非Keep-Alive"><a href="#Keep-Alive-和-非Keep-Alive" class="headerlink" title="Keep-Alive 和 非Keep-Alive"></a>Keep-Alive 和 非Keep-Alive</h1><p><em><strong>非Keep-alive</strong></em>：早期HTTP1.0，浏览器发起http请求需要与服务器建立新的TCP连接，请求处理后连接立即断开，重新请求重新连接。但每一个这样的连接，客户机和服务器都要分配 TCP 的缓冲区和变量，这给服务器带来的严重的负担。</p>
<p><em><strong>Keep-alive</strong></em>：HTTP1.1默认持久连接，同一客户机可以连续请求通过相同的连接进行传送，一台服务器多个web页面也可通过单个TCP连接传送给同一个客户机。但长时间保持TCP连接会导致系统资源被无效占用。</p>
<p>需要正确地设置 keep-alive timeout 参数，当 TCP 连接在传送完最后一个 HTTP 响应，该连接会保持 keepalive_timeout 秒，之后就开始关闭这个链接。</p>
<p>长连接：多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。</p>
<p>短连接：用户数目较多的Web网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。</p>
<br>
<br>

<h1 id="HTTP报文长度"><a href="#HTTP报文长度" class="headerlink" title="HTTP报文长度"></a>HTTP报文长度</h1><ol>
<li>对于静态的文件，直接给出 content-length,也就是本次返回的数据长度</li>
<li>对于动态文件，使用 Transfer-Encoding:chunked 字段，不传输数据长度，客户端只知道是分组传输，这也是订好了协议，客户端收到了会进行组装</li>
</ol>
<br>
<br>

<h1 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h1><ol>
<li>get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。而 post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，Post通过https提交时是ssl加密的，主要用于修改服务器上的资源。</li>
<li>get 请求只支持 URL 编码，post 请求支持多种编码格式。</li>
<li>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</li>
<li>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制</li>
</ol>
<p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务端响应200，请求成功。</p>
<p>对于POST方式的请求，浏览器会先发送http header给服务端，告诉服务端等一下会有数据过来，服务端响应100 continue，告诉浏览器我已经准备接收数据，浏览器再post发送一个data给服务端，服务端响应200，请求成功。</p>
<br>
<br>

<h1 id="GET长度限制"><a href="#GET长度限制" class="headerlink" title="GET长度限制"></a>GET长度限制</h1><p>HTTP 中的 GET 方法是通过 URL 传递数据的，而 <em><strong>URL 本身并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器</strong></em>，例如 IE 浏览器对 URL 的最大限制为 2000多个字符，大概 2KB左右，像 Chrome, FireFox 等浏览器能支持的 URL 字符数更多，其中 FireFox 中 URL 最大长度限制为 65536 个字符，Chrome 浏览器中 URL 最大长度限制为 8182 个字符。并且这个长度不是只针对数据部分，而是针对整个 URL 而言，在这之中，不同的服务器同样影响 URL 的最大长度限制。因此对于特定的浏览器，GET的长度限制不同。</p>
<p>由于 POST 方法请求参数在请求主体中，理论上讲，post 方法是没有大小限制的，而真正起限制作用的是服务器处理程序的处理能力。</p>
<br>
<br>

<h1 id="HTTP-流水线"><a href="#HTTP-流水线" class="headerlink" title="HTTP 流水线"></a>HTTP 流水线</h1><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p>
<p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p>
<br>
<br>


<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<br>
<br>

<h1 id="HTTP和HTTPS建立连接的过程"><a href="#HTTP和HTTPS建立连接的过程" class="headerlink" title="HTTP和HTTPS建立连接的过程"></a>HTTP和HTTPS建立连接的过程</h1><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP（Hyper Text Transfer Protocol: 超文本传输协议） 是一种简单的请求 - 响应协议，被用于在 Web 浏览器和网站服务器之间传递消息。HTTP 使用 TCP（而不是 UDP）作为它的支撑运输层协议。其默认工作在 TCP 协议 80 端口，HTTP 客户机发起一个与服务器的 TCP 连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问 TCP。客户机从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文。类似地，服务器也是从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文。其通信内容以明文的方式发送，不通过任何方式的数据加密。当通信结束时，客户端与服务器关闭连接。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p><img src="https://raw.githubusercontent.com/brucecai-2001/Image/master/20220625162520.png"></p>
<br>
<br>

<h1 id="HTTP和HTTPs的区别"><a href="#HTTP和HTTPs的区别" class="headerlink" title="HTTP和HTTPs的区别"></a>HTTP和HTTPs的区别</h1><ol>
<li>HTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是加密的，安全性较好。</li>
<li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。</li>
<li>HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。</li>
<li>HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程。<br>上一页</li>
</ol>
<br>
<br>

<h1 id="HTTPS-的加密方式"><a href="#HTTPS-的加密方式" class="headerlink" title="HTTPS 的加密方式"></a>HTTPS 的加密方式</h1><p>HTTPS 采用对称加密和非对称加密相结合的方式，首先使用 SSL&#x2F;TLS 协议进行加密传输，为了弥补非对称加密的缺点，HTTPS 采用证书来进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。<br><img src="https://raw.githubusercontent.com/brucecai-2001/Image/master/20220706235248.png"><br><br><br><br></p>
<h1 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h1><p>通过使用 证书 来对通信方进行认证。</p>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。<br><img src="https://raw.githubusercontent.com/brucecai-2001/Image/master/20220707010353.png"><br><br><br><br></p>
<h1 id="HTTP-x2F-1-1-vs-HTTP-x2F-1-0"><a href="#HTTP-x2F-1-1-vs-HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.1 vs HTTP&#x2F;1.0"></a>HTTP&#x2F;1.1 vs HTTP&#x2F;1.0</h1><ol>
<li><p>长连接：1.0默认浏览器和服务器之间是短连接，服务器发送完之后会直接关闭TCP连接，如果想多个HTTP请求复用TCP连接，需要在头部里增加Connection：Keep-Alive ； 1.1的时候默认使用持久连接，减少了资源消耗</p>
</li>
<li><p>缓存处理：1.1请求头中增加了一些和缓存相关的字段，比如If-Match，可以更加灵活地控制缓存策略</p>
</li>
</ol>
<p>访问一个网站的时候，浏览器会向服务器请求很多资源，比如css、js这些静态文件，如果每次请求都要让服务器发送所有资源，请求多了会对服务器造成很大的压力</p>
<p>HTTP为了解决这个问题，就引入了缓存，缓存有两种策略：</p>
<p>1、强缓存：每次请求资源的时候会先去缓存里找，如果有就直接用，没有才去向服务器请求资源</p>
<p>2、对比缓存：每次请求资源的时候先发个消息和服务器确认一下，如果服务器返回304，说明缓存可以用，浏览器就会去缓存里寻找资源</p>
<ol start="3">
<li><p>节约带宽：1.0默认把资源相关的整个对象都发给客户端，但是可能客户端不需要所有的信息，这就浪费了带宽资源；1.1的请求头引入了Range头域，可以只请求部分资源，比如断点下载的时候就可以用Range</p>
</li>
<li><p>错误通知的管理：1.1增加了一些错误状态响应码（24个），比如410表示请求的资源已经被永久删除</p>
</li>
<li><p>Host请求头：1.0的时候每台服务器都绑定唯一的IP地址，后面出现了<strong>虚拟主机</strong>，一个物理服务器可以有多个虚拟主机，一起共享同一个IP地址，所以为了区分不同虚拟主机，1.1添加了host请求头存放主机名</p>
</li>
</ol>
<br>
<br>

<h1 id="HTTP-x2F-1-x-vs-HTTP-x2F-2-0"><a href="#HTTP-x2F-1-x-vs-HTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;1.x vs HTTP&#x2F;2.0"></a>HTTP&#x2F;1.x vs HTTP&#x2F;2.0</h1><ol>
<li>之前版本 数据都是用文本传输，因为文本有多种格式，所以不能很好地适应所有场景； 2.0传送的是二进制，相当于统一了格式</li>
<li>HTTP&#x2F;2.0 支持多路复用。1.1虽然默认复用TCP连接，但是每个请求是串行执行的，如果前面的请求超时，后面的请求只能等着（也就是线头阻塞）； 2.0的时候每个请求有自己的ID，多个请求可以在同一个TCP连接上并行执行，不会互相影响</li>
<li>HTTP&#x2F;2.0 头部压缩。每次进行HTTP请求响应的时候，头部里很多的字段都是重复的，在2.0中，将字段记录到一张表中，头部只需要存放字段对应的编号就行，用的时候只需要拿着编号去表里查找就行，减少了传输的数据量</li>
<li>HTTP&#x2F;2.0 支持服务器推送。 服务器会在客户端没发起请求的时候主动推送一些需要的资源，比如客户端请求一个html文件，服务器发送完之后会把和这个html页面相关的静态文件也发送给客户端，当客户端准备向服务器请求静态文件的时候，就可以直接从缓存中获取，就不需要再发起请求了。</li>
</ol>
<br>
<br>

<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>通常我们有两种方式识别主机：通过主机名或者 IP 地址。人们喜欢便于记忆的主机名表示，而路由器则喜欢定长的、有着层次结构的 IP 地址。为了满足这些不同的偏好，我们就需要一种能够进行主机名到 IP 地址转换的目录服务，域名系统作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。<br><img src="https://raw.githubusercontent.com/brucecai-2001/Image/master/20220702011003.png"><br><img src="https://raw.githubusercontent.com/brucecai-2001/Image/master/20220702011037.png"></p>
<br>
<br>

<h1 id="DNS-为什么用-UDP"><a href="#DNS-为什么用-UDP" class="headerlink" title="DNS 为什么用 UDP"></a>DNS 为什么用 UDP</h1><p>当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>
<br>
<br>

<h1 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h1><p>DNS 劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式。域名劫持往往只能在特定的网络范围内进行，范围外的 DNS 服务器能够返回正常的 IP 地址。攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它组织，并将新的域名信息保存在所指定的 DNS 服务器中，从而使得用户无法通过对原域名进行解析来访问目的网址。</p>
<br>
<br>

<h1 id="套接字有哪些"><a href="#套接字有哪些" class="headerlink" title="套接字有哪些"></a>套接字有哪些</h1><p>套接字（Socket）是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象<br></p>
<ol>
<li>流套接字：基于 TCP 传输协议，主要用于提供面向连接、可靠的数据传输服务。</li>
<li>数据报套接字：基于 UDP 传输协议，对应于无连接的 UDP 服务应用。</li>
<li>原始套接字：用来传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包。</li>
</ol>
<br>
<br>

<h1 id="URI-vs-URL"><a href="#URI-vs-URL" class="headerlink" title="URI vs URL"></a>URI vs URL</h1><p>URI：资源是什么？<br>URL：资源是什么，如何获取？</p>
<h1 id="网页解析全过程"><a href="#网页解析全过程" class="headerlink" title="网页解析全过程"></a>网页解析全过程</h1><p><img src="https://raw.githubusercontent.com/brucecai-2001/Image/master/20220702013053.png"></p>
<ol>
<li><p>DNS 解析：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把域名转换成相应 IP 地址</p>
</li>
<li><p>TCP 连接：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接后，浏览器便可以将 HTTP 请求数据发送给服务器了。</p>
</li>
<li><p>发送 HTTP 请求：浏览器向 Web 服务器发起一个 HTTP 请求，HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是在建立起的TCP连接中，按照HTTP协议标准发送一个索要网页的请求。在这一过程中，会涉及到负载均衡等操作。</p>
</li>
<li><p>处理请求并返回：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器</p>
</li>
<li><p>浏览器渲染：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</p>
</li>
<li><p>断开连接：客户端和服务器通过四次挥手终止 TCP 连接</p>
</li>
</ol>
<br>
<br>

<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>使用代理的主要目的是：</p>
<p>缓存<br><br>负载均衡<br><br>网络访问控制<br><br>访问日志记录<br><br>用户察觉得到正向代理的存在。<br><img src="https://raw.githubusercontent.com/brucecai-2001/Image/master/20220706234308.png"><br><br><br><br><br>反向代理一般位于内部网络中，用户察觉不到。<br><img src="https://raw.githubusercontent.com/brucecai-2001/Image/master/20220706234347.png"></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Xinyu</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://example.com/2022/06/25/[%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C]%E5%BA%94%E7%94%A8%E5%B1%82/">http://example.com/2022/06/25/[%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C]%E5%BA%94%E7%94%A8%E5%B1%82/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Coffee or Tea</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/07/01/%5B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%5D%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97Kafka/">消息队列(2)---Kafka</a>
            
            
            <a class="next" rel="next" href="/2022/06/24/%5B%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%5D%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统概述</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Xinyu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>