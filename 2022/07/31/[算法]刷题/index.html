<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Xinyu">





<title>刷题 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.2.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Xinyu&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Xinyu&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">刷题</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Xinyu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">July 31, 2022&nbsp;&nbsp;21:49:52</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="求整数的二进制中一的数量"><a href="#求整数的二进制中一的数量" class="headerlink" title="求整数的二进制中一的数量"></a>求整数的二进制中一的数量</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">onesCount</span><span class="params">(x <span class="type">int</span>)</span></span> (ones <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> ; x &gt; <span class="number">0</span>; x &amp;= x - <span class="number">1</span> &#123;</span><br><span class="line">        ones++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++&#123;</span><br><span class="line">    <span class="keyword">if</span> (num&gt;&gt;i)&amp;<span class="number">1</span>==<span class="number">1</span>&#123;</span><br><span class="line">        ones++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串</span></span><br><span class="line">sort.Strings(li)</span><br><span class="line"><span class="comment">//整数排序</span></span><br><span class="line">sort.Sort(a)</span><br><span class="line"><span class="comment">// []float64 排序</span></span><br><span class="line">sort.Float64s(slF64)</span><br><span class="line"><span class="comment">//结构体排序 b 是一个结构体切片 实现了Len Less Swap</span></span><br><span class="line">sort.Sort(b)</span><br></pre></td></tr></table></figure>

<h1 id="得到一个字符串内部是否有某一字符-没有返回-1，有返回出现的index"><a href="#得到一个字符串内部是否有某一字符-没有返回-1，有返回出现的index" class="headerlink" title="得到一个字符串内部是否有某一字符,没有返回-1，有返回出现的index"></a>得到一个字符串内部是否有某一字符,没有返回-1，有返回出现的index</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(str, sbstr <span class="type">string</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>

<h1 id="字符对应的数字"><a href="#字符对应的数字" class="headerlink" title="字符对应的数字"></a>字符对应的数字</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;A&#x27;</span> = <span class="number">65</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> = <span class="number">97</span></span><br></pre></td></tr></table></figure>

<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p><strong>频繁求数组中子数组的和</strong><br>存储前缀和: <br></p>
<ol>
<li>题目明确要求不允许使用额外空间的，直接原地修改数组</li>
<li>不限制空间复杂度时，最好额外开辟空间计算，避免数据污染</li>
<li>计算时如果每次只需要获取前一次的累计结果，可以通过数组的方式存储每次获取数组末尾元素的值</li>
<li>如果每次计算需要获取前几次或更多次的结果进行对比时，推荐哈希表的方式，这样可以压缩时间复杂度</li>
</ol>
<h1 id="判断变位字符"><a href="#判断变位字符" class="headerlink" title="判断变位字符"></a>判断变位字符</h1><p>滑动数组+哈希</p>
<h1 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/OrIXps/">https://leetcode.cn/problems/OrIXps/</a></p>
<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>单调栈满足从栈底到栈顶元素递减 <br><br>通常存储下标<br></p>
<h1 id="广度便利"><a href="#广度便利" class="headerlink" title="广度便利"></a>广度便利</h1><p>求第一个右下角节点可以将右边的节点先入队列</p>
<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>container&#x2F;heap：heap源码中定义了一个Interface 的接口，此接口一共包含五个方法，我们定义一个实现此接口的类就实现了一个二叉堆 <br></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An IntHeap is a min-heap of ints.</span></span><br><span class="line"><span class="keyword">type</span> IntHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// Push and Pop use pointer receivers because they modify the slice&#x27;s length,</span></span><br><span class="line">    <span class="comment">// not just its contents.</span></span><br><span class="line">    *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    old := *h</span><br><span class="line">    n := <span class="built_in">len</span>(old)</span><br><span class="line">    x := old[n<span class="number">-1</span>]</span><br><span class="line">    *h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h := &amp;IntHeap&#123;&#125;</span><br><span class="line">heap.Init(h)</span><br></pre></td></tr></table></figure>



<h1 id="前缀树-x2F-字典书"><a href="#前缀树-x2F-字典书" class="headerlink" title="前缀树&#x2F;字典书"></a>前缀树&#x2F;字典书</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">    children [<span class="number">26</span>]*Trie</span><br><span class="line">    isEnd    <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> Trie &#123;</span><br><span class="line">    <span class="keyword">return</span> Trie&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Insert(word <span class="type">string</span>) &#123;</span><br><span class="line">    node := t</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> word &#123;</span><br><span class="line">        ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> node.children[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line">            node.children[ch] = &amp;Trie&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    node.isEnd = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> SearchPrefix(prefix <span class="type">string</span>) *Trie &#123;</span><br><span class="line">    node := t</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> prefix &#123;</span><br><span class="line">        ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> node.children[ch] == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> Search(word <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    node := t.SearchPrefix(word)</span><br><span class="line">    <span class="keyword">return</span> node != <span class="literal">nil</span> &amp;&amp; node.isEnd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span></span> StartsWith(prefix <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.SearchPrefix(prefix) != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/brucecai-2001/Image/master/20220821164331.png"></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> trie <span class="keyword">map</span>[<span class="type">rune</span>]trie</span><br><span class="line">   root := trie&#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> _, s := <span class="keyword">range</span> dictionary &#123;</span><br><span class="line">       cur := root</span><br><span class="line">       <span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">           <span class="keyword">if</span> cur[c] == <span class="literal">nil</span> &#123;</span><br><span class="line">               cur[c] = trie&#123;&#125;</span><br><span class="line">           &#125;</span><br><span class="line">           cur = cur[c]</span><br><span class="line">       &#125;</span><br><span class="line">       cur[<span class="string">&#x27;#&#x27;</span>] = trie&#123;&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h1><p>当 mid 是偶数时， mid+1&#x3D;mid⊕1；<br></p>
<p>当 mid 是奇数时，mid−1&#x3D;mid⊕1。<br></p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="type">int</span>, p <span class="type">int</span>, r <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> p &gt;= r &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取分区位置</span></span><br><span class="line">    q := partition(nums, p, r)</span><br><span class="line">    <span class="comment">// 递归分区（排序是在定位 pivot 的过程中实现的）</span></span><br><span class="line">    quickSort(nums, p, q - <span class="number">1</span>)</span><br><span class="line">    quickSort(nums, q + <span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定位 pivot</span></span><br><span class="line"><span class="comment">// 1,2,3,5,6,4</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="type">int</span>, p <span class="type">int</span>, r <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 以当前数据序列最后一个元素作为初始 pivot</span></span><br><span class="line">    pivot := nums[r]</span><br><span class="line">    <span class="comment">// 初始化 i、j 下标</span></span><br><span class="line">    i := p</span><br><span class="line">    <span class="comment">// 后移 j 下标的遍历过程</span></span><br><span class="line">    <span class="keyword">for</span> j := p; j &lt; r; j++ &#123;</span><br><span class="line">        <span class="comment">// 将比 pivot 小的数丢到 [p...i-1] 中，剩下的 [i...j] 区间都是比 pivot 大的</span></span><br><span class="line">        <span class="keyword">if</span> nums[j] &lt; pivot &#123;</span><br><span class="line">            <span class="comment">// 互换 i、j 下标对应数据</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">            <span class="comment">// 将 i 下标后移一位</span></span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后将 pivot 与 i 下标对应数据值互换</span></span><br><span class="line">    <span class="comment">// 这样一来，pivot 就位于当前数据序列中间，i 也就是 pivot 值对应的下标</span></span><br><span class="line">    nums[i], nums[r] = pivot, nums[i]</span><br><span class="line">    <span class="comment">// 返回 i 作为 pivot 分区位置</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">    quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br><span class="line">    fmt.Println(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取分区位置</span></span><br><span class="line">    p := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">    <span class="comment">// 通过递归分区</span></span><br><span class="line">    left := mergeSort(nums[<span class="number">0</span>:p])</span><br><span class="line">    right := mergeSort(nums[p:])</span><br><span class="line">    <span class="comment">// 排序后合并</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序合并</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left []<span class="type">int</span>, right []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    m, n := <span class="built_in">len</span>(left), <span class="built_in">len</span>(right)</span><br><span class="line">    <span class="comment">// 用于存放结果集</span></span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 任何一个区间遍历完，则退出</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= m || j &gt;= n &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对所有区间数据进行排序</span></span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j] &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, left[i])</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, right[j])</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左侧区间还没有遍历完，将剩余数据放到结果集</span></span><br><span class="line">    <span class="keyword">if</span> i != m &#123;</span><br><span class="line">        <span class="keyword">for</span> ; i &lt; m; i++ &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, left[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果右侧区间还没有遍历完，将剩余数据放到结果集</span></span><br><span class="line">    <span class="keyword">if</span> j != n &#123;</span><br><span class="line">        <span class="keyword">for</span> ; j &lt; n; j++ &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, right[j])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回排序后的结果集</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">    sortedNums := mergeSort(nums)</span><br><span class="line">    fmt.Println(sortedNums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>归并的思路时将一个复杂的问题 a 递归拆解为子问题 b 和 c，再将子问题计算结果合并，最终得到问题的答案，这里我们将归并排序总的时间复杂度设为 T(n)，则 T(n) &#x3D; 2*T(n&#x2F;2) + n <br></p>
<br>

<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span></span>:</span><br><span class="line">    <span class="keyword">if</span> 满⾜结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> 选择 in 选择列表:</span><br><span class="line">    做选择</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    撤销选择</span><br></pre></td></tr></table></figure>

 <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求子集</span></span><br><span class="line">dfs =<span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(path)==k&#123;</span><br><span class="line">           ans = <span class="built_in">append</span>(ans,<span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> idx&gt;n&#123;</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> i:=idx;i&lt;=n;i++&#123;</span><br><span class="line">           path = <span class="built_in">append</span>(path, i)</span><br><span class="line">           dfs(i+<span class="number">1</span>) <span class="comment">// 若包含重复元素， dfs(i)</span></span><br><span class="line">           path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>数据集里的元素有没有重复的，对应的措施就是排序</li>
<li>数据集里的元素允不允许重复使用，对应的措施就是递归的时候index加不加1</li>
<li>for循环的选择，如果i从index开始，一般不需要辅助标记；如果i从0开始（意味着全排列），可能需要辅助标记(visit数组)。<br><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/7p8L0Z/solution/h-by-songsongl-edkk/">https://leetcode.cn/problems/7p8L0Z/solution/h-by-songsongl-edkk/</a></li>
</ol>
<br>

<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p><strong>给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。</strong>  <br></p>
<p><img src="https://raw.githubusercontent.com/brucecai-2001/Image/master/20220904153422.png"></p>
<p><img src="https://raw.githubusercontent.com/brucecai-2001/Image/master/20220904153710.png"></p>
<p><img src="https://raw.githubusercontent.com/brucecai-2001/Image/master/20220904155230.png"></p>
<br>

<h1 id="图的遍历框架"><a href="#图的遍历框架" class="headerlink" title="图的遍历框架"></a>图的遍历框架</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 图遍历框架 */</span></span><br><span class="line">boolean[] visited;</span><br><span class="line">void traverse(Graph graph, <span class="type">int</span> v) &#123;</span><br><span class="line">    <span class="comment">// 防止走回头路进入死循环</span></span><br><span class="line">    <span class="keyword">if</span> (visited[v]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 前序遍历位置，标记节点 v 已访问</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (Vertex neighbor : graph.neighbors(v))</span><br><span class="line">        traverse(graph, neighbor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><p>遍历图染色，图中没有两个相邻的节点颜色一样就是二分图 <br></p>
<br>

<h1 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(grid [][]<span class="type">int</span>, vis [][]<span class="type">bool</span>, i,j <span class="type">int</span>, tmp *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i&lt;<span class="number">0</span> || i&gt;=<span class="built_in">len</span>(grid) || j&lt;<span class="number">0</span> || j&gt;=<span class="built_in">len</span>(grid[<span class="number">0</span>]) || vis[i][j] || grid[i][j] == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    vis[i][j] = <span class="literal">true</span></span><br><span class="line">    *tmp = *tmp + <span class="number">1</span></span><br><span class="line">    dfs(grid,vis,i+<span class="number">1</span>,j,tmp)</span><br><span class="line">    dfs(grid,vis,i<span class="number">-1</span>,j,tmp)</span><br><span class="line">    dfs(grid,vis,i,j+<span class="number">1</span>,tmp)</span><br><span class="line">    dfs(grid,vis,i,j<span class="number">-1</span>,tmp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h1><p>求图的最近距离有关可以考虑使用广度优先搜索解决 <br></p>
<br>

<h1 id="有向无环图遍历"><a href="#有向无环图遍历" class="headerlink" title="有向无环图遍历"></a>有向无环图遍历</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图 graph[][]</span></span><br><span class="line">stk := []<span class="type">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="built_in">len</span>(graph)<span class="number">-1</span> &#123;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, stk...))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, y := <span class="keyword">range</span> graph[x] &#123;</span><br><span class="line">        stk = <span class="built_in">append</span>(stk, y)</span><br><span class="line">        dfs(y)</span><br><span class="line">        stk = stk[:<span class="built_in">len</span>(stk)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<br>

<h1 id="环检测"><a href="#环检测" class="headerlink" title="环检测"></a>环检测</h1><p>建立有向图，遍历+visited[] <br></p>
<br>

<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>DFS: <br><br>拓扑排序的结果就是反转之后的后序遍历结果 <br></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dfs = <span class="function"><span class="keyword">func</span><span class="params">(u <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        visited[u] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> edges[u] &#123;</span><br><span class="line">            <span class="keyword">if</span> visited[v] == <span class="number">0</span> &#123;</span><br><span class="line">                dfs(v)</span><br><span class="line">                <span class="keyword">if</span> !valid &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> visited[v] == <span class="number">1</span> &#123;</span><br><span class="line">                valid = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span></span><br><span class="line">        result = <span class="built_in">append</span>(result, u)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>反转result <br></p>
<p>BFS: <br></p>
<ol>
<li>构造拓扑结构图</li>
<li>将入度为0的加入到队列中</li>
<li>循环将入度为0的拿出,计算拓扑排序<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环将入度为0的拿出,计算拓扑排序</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 拿出入度为0的元素</span></span><br><span class="line">        x := queue[<span class="number">0</span>]</span><br><span class="line">        queue = queue[<span class="number">1</span>:]</span><br><span class="line">        res = <span class="built_in">append</span>(res,x)</span><br><span class="line">        <span class="comment">// 拿出该入度为0元素的所有后继元素，使其入度减1</span></span><br><span class="line">        <span class="keyword">for</span> _, y := <span class="keyword">range</span> graph[x] &#123;</span><br><span class="line">            inDegree[y]--</span><br><span class="line">            <span class="keyword">if</span> inDegree[y] == <span class="number">0</span> &#123;</span><br><span class="line">                queue = <span class="built_in">append</span>(queue, y)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<br>

<h1 id="有向有权图"><a href="#有向有权图" class="headerlink" title="有向有权图"></a>有向有权图</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> edge <span class="keyword">struct</span> &#123;</span><br><span class="line">        to     <span class="type">int</span></span><br><span class="line">        weight <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line">graph := <span class="built_in">make</span>([][]edge, <span class="built_in">len</span>(nodes))</span><br></pre></td></tr></table></figure>

<br>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>在一棵树中，边的数量比节点的数量少 11。如果一棵树有 nn 个节点，则这棵树有 n−1 条边。树是一个连通且无环的无向图，在树中多了一条边之后就会出现环，因此多余的边即为导致环出现的边。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> find <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">    find = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> parent[x] != x &#123;</span><br><span class="line">            parent[x] = find(parent[x])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x]</span><br><span class="line">    &#125;</span><br><span class="line">    union := <span class="function"><span class="keyword">func</span><span class="params">(from, to <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        x, y := find(from), find(to)</span><br><span class="line">        <span class="keyword">if</span> x == y &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        parent[x] = y</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Xinyu</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://example.com/2022/07/31/[%E7%AE%97%E6%B3%95]%E5%88%B7%E9%A2%98/">http://example.com/2022/07/31/[%E7%AE%97%E6%B3%95]%E5%88%B7%E9%A2%98/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Coffee or Tea</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2022/08/04/%5BMySQL%5D%E6%9E%B6%E6%9E%84%E5%92%8C%E5%8E%9F%E7%90%86/">MySQL---架构和执行流程</a>
            
            
            <a class="next" rel="next" href="/2022/07/31/%5B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%5DCookie&Session/">计算机网络(6)---Cookie & Session & Token</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Xinyu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>